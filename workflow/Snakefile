import pandas as pd

def get_samples_fastq_files(wildcards):
    samples = pd.read_csv(f"resources/sample_to_fastq_Run2.txt", sep="\t", header=None, index_col=0, names=['fastq'])
    fq_files = samples.at[wildcards.sample, 'fastq'].replace('/fastq/', '/fastq_trimmed/')
    
    return fq_files

def get_fastq_list(wildcards):
    fq_files = get_samples_fastq_files(wildcards)
    fq_files_list = fq_files.split(' ')[0].split(',') + fq_files.split(' ')[1].split(',')
    
    return fq_files_list

def get_bam_files_per_sample(wildcards,Species):
    samples = pd.read_csv(f"resources/filenames_to_sample.txt", sep="\t", header=None, index_col=0, names=['fastq'])
    file_list = samples.at[wildcards.sample, 'fastq'].split(',')
    file_list = [f'results/{Species}/bwa/{f}.bam' for f in file_list]
    
    return file_list

configfile: "config/config.yaml"

#Species = 'GRCm39'
Species = 'GRCm38'

wildcard_constraints:
    file_se="|".join(config['Fastq_Files']['SE']),
    file_pe="|".join(config['Fastq_Files']['PE']),
    file="|".join(config['Fastq_Files']['PE']+config['Fastq_Files']['SE']),
    sample="|".join(config['Samples']),
    strand="|".join(config['Strands']),
    bin_size="|".join(config['Bin_size']),
    chr="|".join(config['Chromosomes'])

Reads = ['R1','R2']

rule all:
    input:
        # trimming
        #expand(os.path.join(config['outfold_fastq_trimmed'],"{file}_R1_001.fastq.gz"), file=config['Fastq_Files']['SE']),
        #expand(os.path.join(config['outfold_fastq_trimmed'],"{file}_{r}_001.fastq.gz"), file=config['Fastq_Files']['PE'], r=Reads),
        # alignment
        #os.path.join(config['outfold_genome'],Species,"genome.fa.bwt"),
        #expand(os.path.join("results",Species,"bwa","{file_se}.sam"), file_se=config['Fastq_Files']['SE']),
        #expand(os.path.join("results",Species,"bwa","{file_pe}.sam"), file_pe=config['Fastq_Files']['PE']),
        #expand( os.path.join("results",Species,"bwa","{file}.bam"), file=['18035FL-105-01V1-01_S1_L008','PRO_SEQ_CT00_S1','18035FL-105-01_S1_L005','18035FL-105-01_S1_L006'] )
        #expand(os.path.join("results",Species,"bwa","{file}.bam"), file=config['Fastq_Files']['PE']),
        #expand(os.path.join("results",Species,"bwa","{file}.bam"), file=config['Fastq_Files']['SE']),
        #expand(os.path.join("results",Species,"bwa","{sample}.bam"), sample=config['Samples']),
        # coverage
        #expand(os.path.join("results",Species,"coverage","{sample}","coverage_3p_{strand}.bedgraph"), sample=config['Samples'], strand=config['Strands']),
        #expand(os.path.join("results",Species,"norm_coverage","{sample}","NormCoverage_3p_{strand}.bw"),sample=config['Samples'], strand=config['Strands']),
        #expand(os.path.join("results",Species,"binned_norm_coverage","{sample}","NormCoverage_3p_{strand}_bin{bin_size}bp.bw"), sample=config['Samples'], strand=config['Strands'], bin_size=config['Bin_size']),
        #expand(os.path.join("results",Species,"binned_norm_coverage","expression_tables","bin_expression_table_bin{bin_size}bp.csv"),bin_size=config['Bin_size']),
        #expand(os.path.join("results",Species,"binned_norm_coverage","expressed_regions_bin{bin_size}bp.csv"),bin_size=config['Bin_size']),
        #expand(os.path.join("results",Species,"binned_norm_coverage","expressed_regions_bin{bin_size}bp.bed"),bin_size=config['Bin_size']),
        #expand(os.path.join("results",Species,"log_binned_norm_coverage","{sample}","Log2NormCoverage_3p_{strand}_bin{bin_size}bp.bw"), sample=config['Samples'], strand=config['Strands'], bin_size=config['Bin_size']),
        # Phase and amplitude
        #expand(os.path.join("results",Species,"phase_amp","overall_phase_amp_{bin_size}bp.csv"), bin_size=config['Bin_size']),
        #expand(os.path.join("results",Species,"phase_amp","bin_phase_amp_{strand}_{bin_size}bp.bb"), bin_size=config['Bin_size'], strand=config['Strands']),        
        #os.path.join("results",Species,"phase_amp","gene_phase_amp.bb"),
        #os.path.join("results",Species,"phase_amp","gene_antisense_phase_amp.csv"),
        # Kalman
        #expand(os.path.join("results",Species,"binned_norm_coverage","Noise_model_parameters_{bin_size}bp.csv"), bin_size=config['Bin_size'] ),
        #expand(os.path.join("results",Species,"kalman","Gene_Q_1e-5","Kalman_Smoothing_{bin_size}bp.hdf5"), bin_size=config['Bin_size']),
        #expand(os.path.join("results",Species,"phase_amp","gene_kalman_phase_R2_{strand}_{bin_size}bp.bb"), bin_size=config['Bin_size'], strand=config['Strands'])
        #expand(os.path.join("results",Species,"fig","kalman","Gene_Q_1e-5","scatter_Kmax_R2_LL_strand_{bin_size}bp.pdf"), bin_size=config['Bin_size'])
        #expand(os.path.join("results",Species,"kalman","extended_kalman_on_expressed_regions_bin{bin_size}bp.csv"), bin_size=config['Bin_size']),
        expand(os.path.join("results",Species,"kalman","extended_kalman_on_expressed_regions_{strand}_bin{bin_size}bp_phi_amp.bb"), strand=config['Strands'], bin_size=config['Bin_size']),
        expand(os.path.join("results",Species,"kalman","extended_kalman_on_expressed_regions_{strand}_bin{bin_size}bp_ll.bw"), strand=config['Strands'], bin_size=config['Bin_size']),
        # Time-space Fourier
        # expand(os.path.join("results",Species,"fig","space_time_fourier","Bins_{bin_size}bp_sigma_{sigma}Mb","{chr}_amp_pos_k.pdf"),bin_size=config['Bin_size'],sigma=config['Space_Time_Fourier']['sigma_Mb'],chr=config['Chromosomes'])
        #expand(os.path.join("results",Species,"kalman","ll_{win_size}_{d_win}_{chr}_{bin_size}bp.csv"),win_size=config['Kalman']['win_size'],d_win=config['Kalman']['d_win'],chr=config['Chromosomes']bin_size=config['Bin_size']),
        #expand(os.path.join("results",Species,"kalman","mu_{win_size}_{d_win}_{chr}_{bin_size}bp.npy"),win_size=config['Kalman']['win_size'],d_win=config['Kalman']['d_win'],chr=config['Chromosomes'],bin_size=config['Bin_size']),
        #expand(os.path.join("results",Species,"kalman","sigma_{win_size}_{d_win}_{chr}_{bin_size}bp.npy"),win_size=config['Kalman']['win_size'],d_win=config['Kalman']['d_win'],chr=config['Chromosomes'],bin_size=config['Bin_size']),
        #expand(os.path.join("results",Species,"fig","kalman","ll_{win_size}_{d_win}_{chr}_{bin_size}bp.pdf"),win_size=config['Kalman']['win_size'],d_win=config['Kalman']['d_win'],chr=config['Chromosomes'],bin_size=config['Bin_size'])

##-------------------------------------------------------------------##
##   Download gtf, cDNA (coding transcripts), and DNA from Gencode   ##
##-------------------------------------------------------------------##
rule download_gencode_gtf:
    output: 
        os.path.join(config['outfold_genome'],Species,"gene_annotation.gtf")
    params: 
        url = lambda wildcards: config['URLs'][Species]['gtf']
    shell:
        """
        wget -O {output}.gz {params.url}
        gunzip {output}.gz
        """

rule download_gencode_cdna:
    output: 
        os.path.join(config['outfold_genome'],Species,"cdna.fa")
    params: 
        url = lambda wildcards: config['URLs'][Species]['cdna']
    shell:
        """
        wget -O {output}.gz {params.url}
        gunzip {output}.gz
        """

rule download_gencode_genome:
    output: 
        os.path.join(config['outfold_genome'],Species,"genome.fa")
    params:
        url = lambda wildcards: config['URLs'][Species]['genome']
    shell:
        """
        wget -O {output}.gz {params.url}
        gunzip {output}.gz
        """

##-----------------##
##  Trim adapters  ##
##-----------------##
rule cutadapt_se:
    input:
        fq = os.path.join(config['outfold_fastq'],"{file_se}_R1_001.fastq.gz")
    output:
        fq_trimmed = os.path.join(config['outfold_fastq_trimmed'],"{file_se}_R1_001.fastq.gz"),
        report = os.path.join(config['outfold_fastq_trimmed'],"{file_se}_trimmed_report.txt")
    params:
        adapter = config['adapter']['fwd'],
        min_len = 16
    threads: 12
    conda:
        "cutadapt"
    shell:
        """
        cutadapt -a {params.adapter} -o {output.fq_trimmed} -j {threads} -m {params.min_len} {input.fq} > {output.report}
        """

rule cutadapt_pe:
    input:
        fq1 = os.path.join(config['outfold_fastq'],"{file_pe}_R1_001.fastq.gz"),
        fq2 = os.path.join(config['outfold_fastq'],"{file_pe}_R2_001.fastq.gz")
    output:
        fq1_trimmed = os.path.join(config['outfold_fastq_trimmed'],"{file_pe}_R1_001.fastq.gz"),
        fq2_trimmed = os.path.join(config['outfold_fastq_trimmed'],"{file_pe}_R2_001.fastq.gz"),
        report = os.path.join(config['outfold_fastq_trimmed'],"{file_pe}_trimmed_report.txt")
    params:
        adapter_fwd = config['adapter']['fwd'],
        adapter_rev = config['adapter']['rev'],
        min_len = 16
    threads: 12
    conda:
        "cutadapt"
    shell:
        """
        cutadapt -a {params.adapter_fwd} -A {params.adapter_rev} -o {output.fq1_trimmed} -p {output.fq2_trimmed} -j {threads} -m {params.min_len} {input.fq1} {input.fq2} > {output.report}
        """

##-----------------##
##  BWA alignment  ##
##-----------------##
rule bwa_index:
    input:
        genome=os.path.join(config['outfold_genome'],Species,"genome.fa")
    output:
        bwa_index=os.path.join(config['outfold_genome'],Species,"genome.fa.bwt")
    shell:
        """
        bwa index {input.genome}
        """

##------------------##
##  BWA single-end  ##
##------------------##
rule bwa_aln_se:
    input:
        genome=os.path.join(config['outfold_genome'],Species,"genome.fa"),
        genome_index=os.path.join(config['outfold_genome'],Species,"genome.fa.bwt"),
        fq=os.path.join(config['outfold_fastq_trimmed'],"{file_se}_R1_001.fastq.gz")
    output:
        sai=os.path.join("results",Species,"bwa","{file_se}.sai")
    threads: 12
    shell:
        """
        bwa aln -t {threads} -f {output.sai} {input.genome} {input.fq}
        """

rule bwa_samse:
    input:
        genome=os.path.join(config['outfold_genome'],Species,"genome.fa"),
        genome_index=os.path.join(config['outfold_genome'],Species,"genome.fa.bwt"),
        fq=os.path.join(config['outfold_fastq_trimmed'],"{file_se}_R1_001.fastq.gz"),
        sai=os.path.join("results",Species,"bwa","{file_se}.sai")
    output:
        sam=os.path.join("results",Species,"bwa","{file_se}.sam")
    threads: 1
    shell:
        """
        bwa samse -f {output.sam} {input.genome} {input.sai} {input.fq}
        """

rule mapped_uniq_MAPQ_sorted_se:
    input:
        sam=os.path.join("results",Species,"bwa","{file_se}.sam")
    output:
        bam=os.path.join("results",Species,"bwa","{file_se}.bam")
    params:
        MAPQ_min=config['MAPQ_min'],
        mem='4G'
    threads: 12
    shell:
        """
        if [ ! $(hostname -s) == "upnaesrv1" ]; then
            ml gcc/11.3.0 samtools
        fi
        samtools view -@ {threads} -h -q {params.MAPQ_min} -F 4 {input.sam} |\
            awk '$1 ~ /^@/ || $2 == "16" || $2 == "0"' |\
            grep -v 'XA:Z:'| grep -v 'SA:Z:' |\
            samtools sort -@ {threads} -m {params.mem} > {output.bam}
        """

##------------------##
##  BWA paired-end  ##
##------------------##
rule bwa_aln_pe:
    input:
        genome=os.path.join(config['outfold_genome'],Species,"genome.fa"),
        genome_index=os.path.join(config['outfold_genome'],Species,"genome.fa.bwt"),
        fq1=os.path.join(config['outfold_fastq_trimmed'],"{file_pe}_R1_001.fastq.gz"),
        fq2=os.path.join(config['outfold_fastq_trimmed'],"{file_pe}_R2_001.fastq.gz")
    output:
        sai1=os.path.join("results",Species,"bwa","{file_pe}_R1.sai"),
        sai2=os.path.join("results",Species,"bwa","{file_pe}_R2.sai")
    threads: 12
    shell:
        """
        bwa aln -t {threads} -f {output.sai1} {input.genome} {input.fq1}
        bwa aln -t {threads} -f {output.sai2} {input.genome} {input.fq2}
        """

rule bwa_sampe:
    input:
        genome=os.path.join(config['outfold_genome'],Species,"genome.fa"),
        genome_index=os.path.join(config['outfold_genome'],Species,"genome.fa.bwt"),
        fq1=os.path.join(config['outfold_fastq_trimmed'],"{file_pe}_R1_001.fastq.gz"),
        fq2=os.path.join(config['outfold_fastq_trimmed'],"{file_pe}_R2_001.fastq.gz"),
        sai1=os.path.join("results",Species,"bwa","{file_pe}_R1.sai"),
        sai2=os.path.join("results",Species,"bwa","{file_pe}_R2.sai")
    output:
        sam=os.path.join("results",Species,"bwa","{file_pe}.sam")
    threads: 1
    shell:
        """
        bwa sampe -f {output.sam} {input.genome} {input.sai1} {input.sai2} {input.fq1} {input.fq2}
        """

rule mapped_uniq_MAPQ_close_mates_sorted_pe:
    input:
        sam=os.path.join("results",Species,"bwa","{file_pe}.sam")
    output:
        bam=os.path.join("results",Species,"bwa","{file_pe}.bam")
    params:
        MAPQ_min=config['MAPQ_min'],
        mem='4G',
        mate_dist_max=config['mate_dist_max']
    threads: 12
    shell:
        """
        if [ ! $(hostname -s) == "upnaesrv1" ]; then
            ml gcc/11.3.0 samtools
        fi
        samtools view -@ {threads} -h -q {params.MAPQ_min} -F 4 {input.sam} |\
            awk '$1 ~ /^@/ || $2 == "81" || $2 == "97"' |\
            grep -v 'XA:Z:'| grep -v 'SA:Z:' |\
            awk '$1 ~ /^@/ || $7 == "=" && $9 > -{params.mate_dist_max} && $9 < {params.mate_dist_max}' |\
            samtools sort -@ {threads} -m {params.mem} > {output.bam}
        """

##----------------------------##
## Merge PE & SE files, index ##
##----------------------------##
rule merge_bam:
    input:
        files_per_sample = lambda wildcards: get_bam_files_per_sample(wildcards,Species)
    output:
        bam=os.path.join("results",Species,"bwa","{sample}.bam")
    threads: 12
    shell:
        """
        if [ ! $(hostname -s) == "upnaesrv1" ]; then
            ml gcc/11.3.0 samtools
        fi
        samtools merge -@ {threads} -f {output.bam} {input.files_per_sample}
        """

rule sam_index:
    input:
        bam=os.path.join("results",Species,"bwa","{sample}.bam")
    output:
        bam_index=os.path.join("results",Species,"bwa","{sample}.bam.bai")
    shell:
        """
        if [ ! $(hostname -s) == "upnaesrv1" ]; then
            ml gcc/11.3.0 samtools
        fi
        samtools index {input}
        """

##--------------------------------------##
##  Coverage                            ##
##--------------------------------------##
rule chrom_size:
    input:
        genome=os.path.join(config['outfold_genome'],Species,"genome.fa")
    output:
        chrom_size=os.path.join(config['outfold_genome'],Species,"chrom.sizes")
    shell:
        """
        if [ ! $(hostname -s) == "upnaesrv1" ]; then
            ml gcc/11.3.0 samtools
        fi
        samtools faidx {input.genome}
        cut -f1,2 {input.genome}.fai > {output.chrom_size}
        """

# make sure chromosome length are multiples of bin size
rule chrom_size_bin:
    input:
        genome=os.path.join(config['outfold_genome'],Species,"genome.fa")
    output:
        chrom_size=os.path.join(config['outfold_genome'],Species,"chrom.sizes_bin{bin_size}bp")
    shell:
        """
        if [ ! $(hostname -s) == "upnaesrv1" ]; then
            ml gcc/11.3.0 samtools
        fi
        samtools faidx {input.genome}
        cut -f1,2 {input.genome}.fai | awk -v bs={wildcards.bin_size} '{{print $1"\t"$2 + bs - $2 % bs}}' > {output.chrom_size}
        """
        
# for PRO-seq data, we only need the 3'-end of the reads. However the protocol repots reverse complement of the reads. So I take the 5'-end and flip the strand.
rule coverage_bedgraph:
    input:
        bam=os.path.join("results",Species,"bwa","{sample}.bam")
    output:
        bg=os.path.join("results",Species,"coverage","{sample}","coverage_3p_{strand}.bedgraph")
    params:
        strand = lambda wildcards: '-' if wildcards.strand == "forward" else '+' if wildcards.strand == "reverse" else '',
        flag_pe = lambda wildcards: '81' if wildcards.strand == "forward" else '97' if wildcards.strand == "reverse" else '',
        flag_se = lambda wildcards: '16' if wildcards.strand == "forward" else '0' if wildcards.strand == "reverse" else ''
    shell:
        """
        if [ ! $(hostname -s) == "upnaesrv1" ]; then
            ml gcc/11.3.0 samtools bedtools2
        fi
        samtools view -h {input.bam} | awk '$1 ~ /^@/ || $2 == "{params.flag_pe}" || $2 == "{params.flag_se}"' | samtools view -b | bedtools genomecov -ibam stdin -bg -strand {params.strand} -5 | grep "^\<chr" > {output.bg}
        """

rule get_total_count:
    input:
        bg=os.path.join("results",Species,"coverage","{sample}","coverage_3p_{strand}.bedgraph")
    output:
        counts=os.path.join("results",Species,"coverage","{sample}","total_counts_{strand}.txt")
    shell:
        """
        count=$(awk '{{sum+=$4}} END {{print sum}}' {input.bg})
        echo $count > {output.counts}
        """

rule normalize_sort_bedgraph:
    input:
        bg=os.path.join("results",Species,"coverage","{sample}","coverage_3p_{strand}.bedgraph"),
        total_count=os.path.join("results",Species,"coverage","{sample}","total_counts_{strand}.txt"),
        total_counts=expand(os.path.join("results",Species,"coverage","{sample}","total_counts_{strand}.txt"),sample=config['Samples'], strand=config['Strands'])
    output:
        norm_bg=os.path.join("results",Species,"norm_coverage","{sample}","NormCoverage_3p_{strand}.bedgraph")
    shell:
        """
        ./scripts/normalize_bedgraph.sh {input.bg} {input.total_count} {output.norm_bg} {input.total_counts}
        """

rule norm_coverage_bw:
    input:
        norm_bg=os.path.join("results",Species,"norm_coverage","{sample}","NormCoverage_3p_{strand}.bedgraph"),
        chrom_size=os.path.join(config['outfold_genome'],Species,"chrom.sizes")
    output:
        bw=os.path.join("results",Species,"norm_coverage","{sample}","NormCoverage_3p_{strand}.bw")
    params:
        tmp_sorted=os.path.join("results",Species,"norm_coverage","{sample}","NormCoverage_3p_{strand}.sorted.bedgraph")
    shell:
        """
        sort -k1,1 -k2,2n {input.norm_bg} > {params.tmp_sorted}
        bedGraphToBigWig {params.tmp_sorted} {input.chrom_size} {output.bw}
        rm {params.tmp_sorted}
        """

rule make_bin_bed:
    input:
        chrom_size=os.path.join(config['outfold_genome'],Species,"chrom.sizes")
    output:
        bed=os.path.join("results",Species,"binned_norm_coverage","bin{bin_size}bp.bed")
    shell:
        """
        python scripts/make_bins.py --chrom_size {input.chrom_size} --bin_size {wildcards.bin_size} --output {output.bed}
        """

rule bin_coverage:
    input:
        bed=os.path.join("results",Species,"norm_coverage","{sample}","NormCoverage_3p_{strand}.bedgraph"),
        bins=os.path.join("results",Species,"binned_norm_coverage","bin{bin_size}bp.bed")
    output:
        bed=os.path.join("results",Species,"binned_norm_coverage","{sample}","NormCoverage_3p_{strand}_bin{bin_size}bp.bedgraph")
    resources:
        tmpdir = lambda wildcards: f"tmpdir/bin_coverage_{wildcards.sample}_{wildcards.strand}_{wildcards.bin_size}"
    shell:
        """
        if [ ! $(hostname -s) == "upnaesrv1" ]; then
            ml gcc/11.3.0 bedtools2
        fi
        bedtools map -a {input.bins} -b {input.bed} -c 4 -o sum -null out | awk '$4 != "out"' > {output.bed}
        """


rule bin_expression_table:
    input:
        bedgraphs=expand(os.path.join("results",Species,"binned_norm_coverage","{sample}","NormCoverage_3p_{{strand}}_bin{{bin_size}}bp.bedgraph"), sample=config['Samples']),
    output:
        table=os.path.join("results",Species,"binned_norm_coverage","expression_tables","bin_expression_table_{chr}_{strand}_bin{bin_size}bp.csv")
    shell:
        """
        python scripts/make_expression_table_chr_strand.py --chr {wildcards.chr} \
                                                           --bedgraphs {input.bedgraphs} \
                                                           --output {output.table}
        """

rule bin_expression_table_merge_strands:
    input:
        forward_table=os.path.join("results",Species,"binned_norm_coverage","expression_tables","bin_expression_table_{chr}_forward_bin{bin_size}bp.csv"),
        reverse_table=os.path.join("results",Species,"binned_norm_coverage","expression_tables","bin_expression_table_{chr}_reverse_bin{bin_size}bp.csv")
    output:
        table=os.path.join("results",Species,"binned_norm_coverage","expression_tables","bin_expression_table_{chr}_bin{bin_size}bp.csv")
    shell:
        """
        python scripts/make_expression_table_chr.py --forward_table {input.forward_table} \
                                                    --reverse_table {input.reverse_table} \
                                                    --output {output.table}
        """

rule bin_expression_table_merge_chr:
    input:
        tables=expand(os.path.join("results",Species,"binned_norm_coverage","expression_tables","bin_expression_table_{chr}_bin{{bin_size}}bp.csv"),chr=config['Chromosomes'])
    output:
        table=os.path.join("results",Species,"binned_norm_coverage","expression_tables","bin_expression_table_bin{bin_size}bp.csv")
    shell:
        """
        python scripts/make_expression_table.py --chr_tables {input.tables} \
                                                --output {output.table}
        """

rule expressed_regions:
    input:
        expression_table=os.path.join("results",Species,"binned_norm_coverage","expression_tables","bin_expression_table_bin{bin_size}bp.csv")
    params:
        smooth_window =               config['Expressed_regions']['smooth_window'],
        threshold_expressed_regions = config['Expressed_regions']['threshold_expressed_regions'],
        threshold_small_regions =     config['Expressed_regions']['threshold_small_regions']
    output:
        expressed_regions=os.path.join("results",Species,"binned_norm_coverage","expressed_regions_bin{bin_size}bp.csv")
    shell:
        """
        python scripts/get_expressed_regions.py --expression_table {input.expression_table} \
                                                --bin_size {wildcards.bin_size} \
                                                --smooth_window {params.smooth_window} \
                                                --threshold_expressed_regions {params.threshold_expressed_regions} \
                                                --threshold_small_regions {params.threshold_small_regions} \
                                                --expressed_regions {output.expressed_regions}
        """

rule expressed_regions_bed:
    input:
        csv=os.path.join("results",Species,"binned_norm_coverage","expressed_regions_bin{bin_size}bp.csv")
    output:
        bed=os.path.join("results",Species,"binned_norm_coverage","expressed_regions_bin{bin_size}bp.bed")
    shell:
        """
        tail -n +2 {input.csv} | cut -f-3 > {output.bed}
        """

rule expressed_regions_bed_to_bigBed:
    input:
        bed=os.path.join("results",Species,"binned_norm_coverage","expressed_regions_bin{bin_size}bp.bed"),
        chrom_size=os.path.join(config['outfold_genome'],Species,"chrom.sizes")
    output:
        bb=os.path.join("results",Species,"binned_norm_coverage","expressed_regions_bin{bin_size}bp.bb")
    params:
        tmp_sorted=os.path.join("results",Species,"binned_norm_coverage","expressed_regions_bin{bin_size}bp.sorted.bed")
    resources:
        tmpdir = lambda wildcards: f"tmpdir/expressed_regions_bed_to_bigBed_{wildcards.bin_size}"
    shell:
        """
        sort -k 1,1 -k2,2n {input.bed} > {params.tmp_sorted}
        bedToBigBed {params.tmp_sorted} {input.chrom_size} {output.bb}
        rm {params.tmp_sorted}
        """

rule binned_norm_coverage_bw:
    input:
        bed=os.path.join("results",Species,"binned_norm_coverage","{sample}","NormCoverage_3p_{strand}_bin{bin_size}bp.bedgraph"),
        chrom_size=os.path.join(config['outfold_genome'],Species,"chrom.sizes")
    output:
        bw=os.path.join("results",Species,"binned_norm_coverage","{sample}","NormCoverage_3p_{strand}_bin{bin_size}bp.bw")
    params:
        tmp_sorted=os.path.join("results",Species,"binned_norm_coverage","{sample}","NormCoverage_3p_{strand}_bin{bin_size}bp.sorted.bedgraph")
    shell:
        """
        sort -k1,1 -k2,2n {input.bed} > {params.tmp_sorted}
        bedGraphToBigWig {params.tmp_sorted} {input.chrom_size} {output.bw}
        rm {params.tmp_sorted}
        """


rule log2_coverage:
    input:
        bed=os.path.join("results",Species,"binned_norm_coverage","{sample}","NormCoverage_3p_{strand}_bin{bin_size}bp.bedgraph")
    output:
        bed=os.path.join("results",Species,"log_binned_norm_coverage","{sample}","Log2NormCoverage_3p_{strand}_bin{bin_size}bp.bedgraph")
    resources:
        tmpdir = lambda wildcards: f"tmpdir/log2_coverage_{wildcards.sample}_{wildcards.strand}_{wildcards.bin_size}"
    shell:
        """
        awk '{{print $1"\t"$2"\t"$3"\t"log($4+1)/log(2)}}' {input.bed} > {output.bed}
        """

rule log_coverage_bw:
    input:
        bed=os.path.join("results",Species,"log_binned_norm_coverage","{sample}","Log2NormCoverage_3p_{strand}_bin{bin_size}bp.bedgraph"),
        chrom_size=os.path.join(config['outfold_genome'],Species,"chrom.sizes")
    output:
        bw=os.path.join("results",Species,"log_binned_norm_coverage","{sample}","Log2NormCoverage_3p_{strand}_bin{bin_size}bp.bw")
    params:
        tmp_sorted=os.path.join("results",Species,"log_binned_norm_coverage","{sample}","Log2NormCoverage_3p_{strand}_bin{bin_size}bp.sorted.bedgraph")
    shell:
        """
        sort -k1,1 -k2,2n {input.bed} > {params.tmp_sorted}
        bedGraphToBigWig {params.tmp_sorted} {input.chrom_size} {output.bw}
        rm {params.tmp_sorted}
        """

##--------------------------------------##
##  Get bin phase and amplitude         ##
##--------------------------------------##
rule get_overall_phase_amp:
    input:
        expand(os.path.join("results",Species,"binned_norm_coverage","{sample}","NormCoverage_3p_{strand}_bin{{bin_size}}bp.bw"), sample=config['Samples'], strand=config['Strands']) # only for dependency
    output:
        table=os.path.join("results",Species,"phase_amp","overall_phase_amp_{bin_size}bp.csv"),
        fig=os.path.join("results",Species,"fig","overall_phase_amp_{bin_size}bp.pdf")
    params:
        bw_folder=os.path.join("results",Species,"binned_norm_coverage")
    shell:
        """
        python scripts/get_overall_phase_amp.py --bin_size {wildcards.bin_size} \
                                                --bw_folder {params.bw_folder} \
                                                --out_table {output.table} \
                                                --out_fig {output.fig}
        """ 
    
rule get_bin_phase_amp:
    input:
        bw=expand(os.path.join("results",Species,"binned_norm_coverage","{sample}","NormCoverage_3p_{{strand}}_bin{{bin_size}}bp.bw"), sample=config['Samples'])
    output:
        table=os.path.join("results",Species,"phase_amp","bin_phase_amp_{strand}_{bin_size}bp.csv")
    params:
        bw_folder=os.path.join("results",Species,"binned_norm_coverage")
    threads: 12
    shell:
        """
        python scripts/get_bin_phase_amp.py --bin_size {wildcards.bin_size} \
                                            --strand {wildcards.strand} \
                                            --bw_folder {params.bw_folder} \
                                            --out_table {output.table}
        """

rule get_bin_phase_amp_bed:
    input:
        table=os.path.join("results",Species,"phase_amp","bin_phase_amp_{strand}_{bin_size}bp.csv")
    output:
        bed=os.path.join("results",Species,"phase_amp","bin_phase_amp_{strand}_{bin_size}bp.bed")
    shell:
        """
        python scripts/get_bin_phase_amp_bed_track.py --in_table {input.table} \
                                                      --out_bed {output.bed}
        """

rule bin_bed_to_bigBed:
    input:
        bed=os.path.join("results",Species,"phase_amp","bin_phase_amp_{strand}_{bin_size}bp.bed"),
        chrom_size=os.path.join(config['outfold_genome'],Species,"chrom.sizes")
    output:
        bb=os.path.join("results",Species,"phase_amp","bin_phase_amp_{strand}_{bin_size}bp.bb")
    params:
        tmp_sorted=os.path.join("results",Species,"phase_amp","bin_phase_amp_{strand}_{bin_size}bp.sorted.bed")
    resources:
        tmpdir = lambda wildcards: f"tmpdir/bin_bed_to_bigBed_{wildcards.strand}_{wildcards.bin_size}"
    shell:
        """
        sort -k 1,1 -k2,2n {input.bed} > {params.tmp_sorted}
        bedToBigBed {params.tmp_sorted} {input.chrom_size} {output.bb}
        rm {params.tmp_sorted}
        """

##--------------------------------------##
##  Get gene phase and amplitude        ##
##--------------------------------------##
rule get_gene_gtf:
    input:
        gtf=os.path.join(config['outfold_genome'],Species,"gene_annotation.gtf")
    output:
        gtf_gene=os.path.join(config['outfold_genome'],Species,"gene_protein_coding.gtf")
    shell:
        """
        ./scripts/get_gene_gtf.sh {input.gtf} {output.gtf_gene}
        """

rule get_gene_phase_amp:
    input:
        gtf=os.path.join(config['outfold_genome'],Species,"gene_protein_coding.gtf"),
        bw=expand(os.path.join("results",Species,"norm_coverage","{sample}","NormCoverage_3p_{strand}.bw"), sample=config['Samples'], strand=config['Strands'])
    output:
        table=os.path.join("results",Species,"phase_amp","gene_phase_amp.csv")
    params:
        bed_folder=os.path.join("results",Species,"norm_coverage")
    threads: 24
    shell:
        """
        python scripts/get_gene_phase_amp.py --gtf {input.gtf} \
                                             --bed_folder {params.bed_folder} \
                                             --out_table {output.table}
        """

rule get_gene_phase_amp_bed:
    input:
        table=os.path.join("results",Species,"phase_amp","gene_phase_amp.csv")
    output:
        bed=os.path.join("results",Species,"phase_amp","gene_phase_amp.bed"),
        fig=os.path.join("results",Species,"fig","gene_phase_amp.pdf")
    shell:
        """
        python scripts/get_gene_phase_amp_bed_track.py --in_table {input.table} \
                                                       --out_bed {output.bed} \
                                                       --out_fig {output.fig}
        """

rule gene_bed_to_bigBed:
    input:
        bed=os.path.join("results",Species,"phase_amp","gene_phase_amp.bed"),
        chrom_size=os.path.join(config['outfold_genome'],Species,"chrom.sizes")
    output:
        bb=os.path.join("results",Species,"phase_amp","gene_phase_amp.bb")
    params:
        tmp_sorted=os.path.join("results",Species,"phase_amp","gene_phase_amp.sorted.bed")
    shell:
        """
        sort -k 1,1 -k2,2n {input.bed} > {params.tmp_sorted}
        bedToBigBed {params.tmp_sorted} {input.chrom_size} {output.bb}
        rm {params.tmp_sorted}
        """

rule get_gene_antisense_phase_amp:
    input:
        gtf=os.path.join(config['outfold_genome'],Species,"gene_protein_coding.gtf"),
        bed=expand(os.path.join("results",Species,"norm_coverage","{sample}","NormCoverage_3p_{strand}.bedgraph"), sample=config['Samples'], strand=config['Strands'])
    output:
        table=os.path.join("results",Species,"phase_amp","gene_antisense_phase_amp.csv")
    params:
        bed_folder=os.path.join("results",Species,"norm_coverage")
    threads: 24
    shell:
        """
        python scripts/get_gene_phase_amp.py --gtf {input.gtf} \
                                             --bed_folder {params.bed_folder} \
                                             --out_table {output.table} \
                                             --antisense
        """

##--------------------------------------##
##  Kalman Filter                       ##
##--------------------------------------##
rule noise_model:
    input:
        bw=expand(os.path.join("results",Species,"binned_norm_coverage","{sample}","NormCoverage_3p_{strand}_bin{{bin_size}}bp.bw"), sample=config['Samples'], strand=config['Strands'])
    output:
        noise_model_parameters=os.path.join("results",Species,"binned_norm_coverage","Noise_model_parameters_{bin_size}bp.csv"),
        fig=os.path.join("results",Species,"fig","noise_model_{bin_size}bp.pdf")
    params:
        bw_folder=os.path.join("results",Species,"binned_norm_coverage")
    threads: 12
    shell:
        """
        python scripts/noise_model.py --bin_size {wildcards.bin_size} \
                                      --out_table {output.noise_model_parameters} \
                                      --out_fig {output.fig} \
                                      --bw_folder {params.bw_folder}
        """

rule Kalman_gene_smoothing:
    input:
        tables=expand(os.path.join("results",Species,"binned_norm_coverage","{sample}","NormCoverage_3p_{strand}_bin{{bin_size}}bp.bw"), sample=config['Samples'], strand=config['Strands']), # only for dependency
        noise_model_parameters=os.path.join("results",Species,"binned_norm_coverage","Noise_model_parameters_{bin_size}bp.csv"),
        gene_phase_amp=os.path.join("results",Species,"phase_amp","gene_phase_amp.csv")
    output:
        os.path.join("results",Species,"kalman","Gene_Q_1e-5","Kalman_Smoothing_{bin_size}bp.hdf5")
    params:
        bw_folder=os.path.join("results",Species,"binned_norm_coverage")
    threads: 24
    shell:
        """
        python scripts/Kalman_filter_on_genes.py --bin_size {wildcards.bin_size} \
                                                 --bw_folder {params.bw_folder} \
                                                 --noise_model_parameters {input.noise_model_parameters} \
                                                 --gene_phase_amp {input.gene_phase_amp} \
                                                 --out_hdf5 {output} \
                                                 --n_threads {threads}
        """

rule plot_Kalman_gene_smoothing:
    input:
        in_hdf5=os.path.join("results",Species,"kalman","Gene_Q_1e-5","Kalman_Smoothing_{bin_size}bp.hdf5"),
        gtf=os.path.join(config['outfold_genome'],Species,"gene_protein_coding.gtf")
    output:
        fig=os.path.join("results",Species,"fig","kalman","Gene_Q_1e-5","scatter_Kmax_R2_LL_strand_{bin_size}bp.pdf")
    params:
        bw_folder=os.path.join("results",Species,"binned_norm_coverage")
    shell:
        """
        python scripts/plot_kalman_on_genes.py --bin_size {wildcards.bin_size} \
                                               --bw_folder {params.bw_folder} \
                                               --gtf {input.gtf} \
                                               --in_hdf5 {input.in_hdf5} \
                                               --out_fig {output.fig}
        """

rule Kalman_gene_smoothing_bed:
    input:
        in_hdf5=os.path.join("results",Species,"kalman","Gene_Q_1e-5","Kalman_Smoothing_{bin_size}bp.hdf5"),
        chrom_size=os.path.join(config['outfold_genome'],Species,"chrom.sizes")
    output:
        bed=os.path.join("results",Species,"phase_amp","gene_kalman_phase_R2_{strand}_{bin_size}bp.bed")
    params:
        strand = lambda wildcards: '+' if wildcards.strand == "forward" else '-' if wildcards.strand == "reverse" else '',
    threads:
        12
    shell:
        """
        python scripts/get_gene_kalman_smoothing_bed_track.py --in_kalman_hdf5 {input.in_hdf5} \
                                                              --chrom_size {input.chrom_size} \
                                                              --bin_size {wildcards.bin_size} \
                                                              --strand {params.strand} \
                                                              --out_bed {output.bed}
        """


rule kalman_gene_bed_to_bigBed:
    input:
        bed=os.path.join("results",Species,"phase_amp","gene_kalman_phase_R2_{strand}_{bin_size}bp.bed"),
        chrom_size=os.path.join(config['outfold_genome'],Species,"chrom.sizes")
    output:
        bb=os.path.join("results",Species,"phase_amp","gene_kalman_phase_R2_{strand}_{bin_size}bp.bb")
    params:
        sorted_bed = lambda wildcards: os.path.join("results",Species,"phase_amp",f"gene_kalman_phase_R2_{wildcards.strand}_{wildcards.bin_size}bp.sorted.bed")
    resources:
        tmpdir = lambda wildcards: f"tmpdir/kalman_gene_bed_to_bigBed_{wildcards.strand}_{wildcards.bin_size}"
    shell:
        """
        sort -k 1,1 -k2,2n {input.bed} > {params.sorted_bed}
        bedToBigBed {params.sorted_bed} {input.chrom_size} {output.bb}
        """

rule Kalman_smoothing:
    input:
        expand(os.path.join("results",Species,"binned_norm_coverage","{sample}","NormCoverage_3p_{strand}_bin{{bin_size}}bp.bw"), sample=config['Samples'], strand=config['Strands']) # only for dependency
    output:
        ll=os.path.join("results",Species,"kalman","ll_{win_size}_{d_win}_{chr}_{bin_size}bp.csv"),
        mu=os.path.join("results",Species,"kalman","mu_{win_size}_{d_win}_{chr}_{bin_size}bp.npy"),
        sigma=os.path.join("results",Species,"kalman","sigma_{win_size}_{d_win}_{chr}_{bin_size}bp.npy"),
        r2=os.path.join("results",Species,"kalman","r2_{win_size}_{d_win}_{chr}_{bin_size}bp.npy")
    params:
        bw_folder=os.path.join("results",Species,"binned_norm_coverage")
    threads:
        12
    shell:
        """
        python scripts/Kalman_filter_on_for_waves.py --bin_size {wildcards.bin_size} \
                                                     --bw_folder {params.bw_folder} \
                                                     --chr {wildcards.chr} \
                                                     --win_size {wildcards.win_size} \
                                                     --d_win {wildcards.d_win} \
                                                     --out_ll {output.ll} \
                                                     --out_mu {output.mu} \
                                                     --out_sigma {output.sigma} \
                                                     --out_r2 {output.r2}
        """
        

rule plot_Kalman_smoothing:
    input:
        ll=os.path.join("results",Species,"kalman","ll_{win_size}_{d_win}_{chr}_{bin_size}bp.csv"),
        mu=os.path.join("results",Species,"kalman","mu_{win_size}_{d_win}_{chr}_{bin_size}bp.npy"),
        sigma=os.path.join("results",Species,"kalman","sigma_{win_size}_{d_win}_{chr}_{bin_size}bp.npy"),
        r2=os.path.join("results",Species,"kalman","r2_{win_size}_{d_win}_{chr}_{bin_size}bp.npy")
    output:
        fig=os.path.join("results",Species,"fig","kalman","ll_{win_size}_{d_win}_{chr}_{bin_size}bp.pdf")
    params:
        bw_folder=os.path.join("results",Species,"binned_norm_coverage")
    shell:
        """
        python scripts/plot_kalman_filter.py --bin_size {wildcards.bin_size} \
                                             --bw_folder {params.bw_folder} \
                                             --chr {wildcards.chr} \
                                             --win_size {wildcards.win_size} \
                                             --d_win {wildcards.d_win} \
                                             --in_ll {input.ll} \
                                             --in_mu {input.mu} \
                                             --in_sigma {input.sigma} \
                                             --in_r2 {input.r2} \
                                             --out_ll {output.fig}
        """


rule extended_kalman_on_expressed_regions:
    input:
        expressed_regions=os.path.join("results",Species,"binned_norm_coverage","expressed_regions_bin{bin_size}bp.bed"),
        noise_model_parameters=os.path.join("results",Species,"binned_norm_coverage","Noise_model_parameters_{bin_size}bp.csv")
    params:
        bw_folder=os.path.join("results",Species,"binned_norm_coverage")
    output:
        table=os.path.join("results",Species,"kalman","extended_kalman_on_expressed_regions_bin{bin_size}bp.csv"),
    threads: 72
    shell:
        """
        python scripts/extended_kalman_on_expressed_regions.py --bin_size {wildcards.bin_size} \
                                                               --expressed_regions {input.expressed_regions} \
                                                               --noise_model {input.noise_model_parameters} \
                                                               --bw_folder {params.bw_folder} \
                                                               --out_table {output.table} \
                                                               --threads {threads}
        """

rule extended_kalman_bed:
    input:
        kalman=os.path.join("results",Species,"kalman","extended_kalman_on_expressed_regions_bin{bin_size}bp.csv"),
        expressed_regions=os.path.join("results",Species,"binned_norm_coverage","expressed_regions_bin{bin_size}bp.bed")
    output:
        bed_phi=os.path.join("results",Species,"kalman","extended_kalman_on_expressed_regions_{strand}_bin{bin_size}bp_phi_amp.bed"),
        bed_ll=os.path.join("results",Species,"kalman","extended_kalman_on_expressed_regions_{strand}_bin{bin_size}bp_ll.bedgraph")
    params:
        strand = lambda wildcards: '+' if wildcards.strand == "forward" else '-' if wildcards.strand == "reverse" else ''
    shell:
        """
        python scripts/extended_kalman_bed_tracks.py --kalman_table {input.kalman} \
                                                     --expressed_regions {input.expressed_regions} \
                                                     --strand {params.strand} \
                                                     --out_bed_phase_amp {output.bed_phi} \
                                                     --out_bed_ll {output.bed_ll}
        """

rule extended_kalman_phi_amp_bb:
    input:
        bed=os.path.join("results",Species,"kalman","extended_kalman_on_expressed_regions_{strand}_bin{bin_size}bp_phi_amp.bed"),
        chrom_size=os.path.join(config['outfold_genome'],Species,"chrom.sizes")
    output:
        bb=os.path.join("results",Species,"kalman","extended_kalman_on_expressed_regions_{strand}_bin{bin_size}bp_phi_amp.bb"),
    params:
        tmp_sorted=os.path.join("results",Species,"kalman","extended_kalman_on_expressed_regions_{strand}_bin{bin_size}bp_phi_amp.sorted.bed")
    shell:
        """
        sort -k 1,1 -k2,2n {input.bed} > {params.tmp_sorted}
        bedToBigBed {params.tmp_sorted} {input.chrom_size} {output.bb}
        rm {params.tmp_sorted}
        """

rule extended_kalman_ll_bw:
    input:
        bg=os.path.join("results",Species,"kalman","extended_kalman_on_expressed_regions_{strand}_bin{bin_size}bp_ll.bedgraph"),
        chrom_size=os.path.join(config['outfold_genome'],Species,"chrom.sizes")
    output:
        bw=os.path.join("results",Species,"kalman","extended_kalman_on_expressed_regions_{strand}_bin{bin_size}bp_ll.bw")
    params:
        tmp_sorted=os.path.join("results",Species,"kalman","extended_kalman_on_expressed_regions_{strand}_bin{bin_size}bp_ll.sorted.bedgraph")
    shell:
        """
        sort -k 1,1 -k2,2n {input.bg} > {params.tmp_sorted}
        bedGraphToBigWig {params.tmp_sorted} {input.chrom_size} {output.bw}
        rm {params.tmp_sorted}
        """

##--------------------------------------##
##  Time-space Fourier                  ##
##--------------------------------------##
rule time_space_fourier_transform:
    input:
        overall_phase_amp=os.path.join("results",Species,"phase_amp","overall_phase_amp_{bin_size}bp.csv")
    output:
        amplitude=os.path.join("results",Species,"space_time_fourier","Bins_{bin_size}bp_sigma_{sigma}Mb","{chr}_amp_pos_k.csv"),
        phase=os.path.join("results",Species,"space_time_fourier","Bins_{bin_size}bp_sigma_{sigma}Mb","{chr}_phase_pos_k.csv"),
        mu=os.path.join("results",Species,"space_time_fourier","Bins_{bin_size}bp_sigma_{sigma}Mb","{chr}_mu_pos.csv")
    params:
        bw_folder=os.path.join("results",Species,"binned_norm_coverage")
    threads: 24
    shell:
        """
        python scripts/time_space_Fourrier_transform.py --bin_size {wildcards.bin_size} \
                                                        --bw_folder {params.bw_folder} \
                                                        --overall_phase_amp_table {input.overall_phase_amp} \
                                                        --out_table_amp {output.amplitude} \
                                                        --out_table_phase {output.phase} \
                                                        --out_table_mu {output.mu} \
                                                        --chr {wildcards.chr} \
                                                        --sigma {wildcards.sigma}
        """

rule plot_time_space_fourier_transform:
    input:
        amplitude=os.path.join("results",Species,"space_time_fourier","Bins_{bin_size}bp_sigma_{sigma}Mb","{chr}_amp_pos_k.csv"),
        phase=os.path.join("results",Species,"space_time_fourier","Bins_{bin_size}bp_sigma_{sigma}Mb","{chr}_phase_pos_k.csv"),
        mu=os.path.join("results",Species,"space_time_fourier","Bins_{bin_size}bp_sigma_{sigma}Mb","{chr}_mu_pos.csv")
    output:
        fig=os.path.join("results",Species,"fig","space_time_fourier","Bins_{bin_size}bp_sigma_{sigma}Mb","{chr}_amp_pos_k.pdf")
    shell:
        """
        python scripts/plot_time_space_fourier_transform.py --bin_size {wildcards.bin_size} \
                                                            --sigma {wildcards.sigma} \
                                                            --table_amp {input.amplitude} \
                                                            --table_phase {input.phase} \
                                                            --table_mu {input.mu} \
                                                            --outfig {output.fig} \
                                                            --chr {wildcards.chr}       
        """


##--------------------------------------##
##  Track Hub                           ##
##--------------------------------------##

 























 ##----------------------------------------##
##  Generate STAR genome index and align  ##
##----------------------------------------##
rule star_genome_index:
    input:
        genome = os.path.join(config['outfold_genome'],Species,"genome.fa"),
        gtf = os.path.join(config['outfold_genome'],Species,"gene_annotation.gtf"),
    output:
        genome_dir = directory(os.path.join(config['outfold_genome'],Species,f"star_index_{config['read_length']['PE']-1}/"))
    params:
        limitram = 200000000000,
        overhang = config['read_length']['PE']-1
    threads: 24
    shell:
        """
        if [ ! $(hostname -s) == "upnaesrv1" ]; then
            module load gcc/11.3.0 star
        fi
        mkdir -p {output.genome_dir}
        STAR --runMode genomeGenerate \
             --genomeDir {output.genome_dir} \
             --genomeFastaFiles {input.genome} \
             --sjdbGTFfile {input.gtf} \
             --sjdbOverhang {params.overhang} \
             --limitGenomeGenerateRAM {params.limitram} \
             --runThreadN {threads}
        """

# first run scripts/make_samples_to_fastq.sh to generate resources/sample_to_fastq_Run{i}.txt
rule star_align:
    input:
        fq_files = get_fastq_list, # get_fastq_list is a function that returns a list of trimmed fastq files for a given sample (for dependence only)
        gtf = os.path.join(config['outfold_genome'],Species,"gene_annotation.gtf"),
        genome_dir = os.path.join(config['outfold_genome'],Species,f"star_index_{config['read_length']['PE']-1}/")
    output:
        os.path.join("results",Species,"star","{sample}","Aligned.sortedByCoord.out.bam"),
        os.path.join("results",Species,"star","{sample}","Log.final.out")
    params:
        fq_cmd_str = get_samples_fastq_files, # get_samples_fastq_files is a function that returns a string of trimmed fastq files for a given sample
        prefix=os.path.join("results",Species,"star","{sample}/"),
        outsamtype = "BAM SortedByCoordinate",
        limitram = 120000000000,
        minlen = 16
    threads: 12
    shell:
        """
        if [ ! $(hostname -s) == "upnaesrv1" ]; then
            module load gcc/11.3.0 star
        fi
        STAR --runMode alignReads \
             --genomeDir {input.genome_dir} \
             --readFilesIn {params.fq_cmd_str} \
             --runThreadN {threads} \
             --readFilesCommand gunzip -c \
             --outFileNamePrefix {params.prefix} \
             --outSAMtype {params.outsamtype} \
             --limitBAMsortRAM {params.limitram} \
             --sjdbGTFfile {input.gtf} \
             --outFilterMatchNminOverLread 0 \
             --outFilterMatchNmin {params.minlen}
        """
